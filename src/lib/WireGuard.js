'use strict';

const fs = require('node:fs/promises');
const path = require('path');
const debug = require('debug')('WireGuard');
const crypto = require('node:crypto');
const QRCode = require('qrcode');

const Util = require('./Util');
const ServerError = require('./ServerError');

const {
  WG_PATH,
  WG_HOST,
  WG_PORT,
  WG_CONFIG_PORT,
  WG_MTU,
  WG_DEFAULT_DNS,
  WG_DEFAULT_ADDRESS,
  WG_PERSISTENT_KEEPALIVE,
  WG_ALLOWED_IPS,
  WG_PRE_UP,
  WG_POST_UP,
  WG_PRE_DOWN,
  WG_POST_DOWN,
} = require('../config');

module.exports = class WireGuard {

  constructor() {
    this.dataUsageUpdates = {};
    this.updateInterval = 3600000;
    this.startPeriodicUpdates();
    this.previousTransfers = {};
  }

  async __buildConfig() {
    this.__configPromise = Promise.resolve().then(async () => {
      if (!WG_HOST) {
        throw new Error('WG_HOST Environment Variable Not Set!');
      }

      debug('Loading configuration...');
      let config;
      try {
        config = await fs.readFile(path.join(WG_PATH, 'wg0.json'), 'utf8');
        config = JSON.parse(config);
        debug('Configuration loaded.');
      } catch (err) {
        const privateKey = await Util.exec('wg genkey');
        const publicKey = await Util.exec(`echo ${privateKey} | wg pubkey`, {
          log: 'echo ***hidden*** | wg pubkey',
        });
        const address = WG_DEFAULT_ADDRESS.replace('x', '1');

        config = {
          server: {
            privateKey,
            publicKey,
            address,
          },
          clients: {},
        };
        debug('Configuration generated.');
      }

      return config;
    });

    return this.__configPromise;
  }

  async getConfig() {
    if (!this.__configPromise) {
      const config = await this.__buildConfig();

      await this.__saveConfig(config);
      await Util.exec('wg-quick down wg0').catch(() => {});
      await Util.exec('wg-quick up wg0').catch((err) => {
        if (err && err.message && err.message.includes('Cannot find device "wg0"')) {
          throw new Error('WireGuard exited with the error: Cannot find device "wg0"\nThis usually means that your host\'s kernel does not support WireGuard!');
        }

        throw err;
      });
      // await Util.exec(`iptables -t nat -A POSTROUTING -s ${WG_DEFAULT_ADDRESS.replace('x', '0')}/24 -o ' + WG_DEVICE + ' -j MASQUERADE`);
      // await Util.exec('iptables -A INPUT -p udp -m udp --dport 51820 -j ACCEPT');
      // await Util.exec('iptables -A FORWARD -i wg0 -j ACCEPT');
      // await Util.exec('iptables -A FORWARD -o wg0 -j ACCEPT');
      await this.__syncConfig();
    }

    return this.__configPromise;
  }

  async saveConfig() {
    const config = await this.getConfig();
    await this.__saveConfig(config);
    await this.__syncConfig();
  }

  async __saveConfig(config) {
    let result = `
# Note: Do not edit this file directly.
# Your changes will be overwritten!

# Server
[Interface]
PrivateKey = ${config.server.privateKey}
Address = ${config.server.address}/24
ListenPort = ${WG_PORT}
PreUp = ${WG_PRE_UP}
PostUp = ${WG_POST_UP}
PreDown = ${WG_PRE_DOWN}
PostDown = ${WG_POST_DOWN}
`;

    for (const [clientId, client] of Object.entries(config.clients)) {
      if (!client.enabled) continue;

      result += `

# Client: ${client.name} (${clientId})
[Peer]
PublicKey = ${client.publicKey}
${client.preSharedKey ? `PresharedKey = ${client.preSharedKey}\n` : ''
}AllowedIPs = ${client.address}/32`;
    }

    debug('Config saving...');
    await fs.writeFile(path.join(WG_PATH, 'wg0.json'), JSON.stringify(config, false, 2), {
      mode: 0o660,
    });
    await fs.writeFile(path.join(WG_PATH, 'wg0.conf'), result, {
      mode: 0o600,
    });
    debug('Config saved.');
  }

  async __syncConfig() {
    debug('Config syncing...');
    await Util.exec('wg syncconf wg0 <(wg-quick strip wg0)');
    debug('Config synced.');
  }

  async getClients() {
    const config = await this.getConfig();
    const clients = Object.entries(config.clients).map(([clientId, client]) => ({
      id: clientId,
      name: client.name,
      enabled: client.enabled,
      address: client.address,
      publicKey: client.publicKey,
      createdAt: new Date(client.createdAt),
      updatedAt: new Date(client.updatedAt),
      allowedIPs: client.allowedIPs,
      days: client.days,
      dataLimit: client.dataLimit,
      dataUsage: client.dataUsage,
      activatedAt: client.activatedAt,
      remainingDays: client.remainingDays || null, // نمایش remainingDays
      downloadableConfig: 'privateKey' in client,
      persistentKeepalive: null,
      latestHandshakeAt: null,
      transferRx: null,
      transferTx: null,
    }));
    // گرفتن وضعیت WireGuard
    const dump = await Util.exec('wg show wg0 dump', {
      log: false,
    });

    dump
      .trim()
      .split('\n')
      .slice(1)
      .forEach((line) => {
        const [
          publicKey,
          preSharedKey, // eslint-disable-line no-unused-vars
          endpoint, // eslint-disable-line no-unused-vars
          allowedIps, // eslint-disable-line no-unused-vars
          latestHandshakeAt,
          transferRx,
          transferTx,
          persistentKeepalive,
        ] = line.split('\t');

        const client = clients.find((client) => client.publicKey === publicKey);
        if (!client) return;

        client.latestHandshakeAt = latestHandshakeAt === '0'
          ? null
          : new Date(Number(`${latestHandshakeAt}000`));
        client.persistentKeepalive = persistentKeepalive;

        // ذخیره مقادیر قبلی transferRx و transferTx
        if (!this.previousTransfers[client.id]) {
          this.previousTransfers[client.id] = {
            transferRx: Number(transferRx),
            transferTx: Number(transferTx),
          };
        }

        // محاسبه تغییرات جدید در transferRx و transferTx
        const rxChange = Number(transferRx) - this.previousTransfers[client.id].transferRx;
        const txChange = Number(transferTx) - this.previousTransfers[client.id].transferTx;

        // به‌روزرسانی مقادیر قبلی
        const totalChange = rxChange + txChange;
        const totalChangeInGB = totalChange / 1073741824; // تبدیل بایت به گیگابایت

        // محاسبه حجم مصرف شده بر اساس گیگابایت و ذخیره آن در client.dataUsage
        client.dataUsage += totalChangeInGB;

        // به‌روزرسانی مصرف داده در سرور
        this.updateClientDataUsage({ clientId: client.id, dataUsage: client.dataUsage });
      });

    return clients;
  }

  async getClient({ clientId }) {
    const config = await this.getConfig();
    const client = config.clients[clientId];
    if (!client) {
      throw new ServerError(`Client Not Found: ${clientId}`, 404);
    }

    return client;
  }

  async getClientConfiguration({ clientId }) {
    const config = await this.getConfig();
    const client = await this.getClient({ clientId });

    return `
[Interface]
PrivateKey = ${client.privateKey ? `${client.privateKey}` : 'REPLACE_ME'}
Address = ${client.address}/24
${WG_DEFAULT_DNS ? `DNS = ${WG_DEFAULT_DNS}\n` : ''}\
${WG_MTU ? `MTU = ${WG_MTU}\n` : ''}\

[Peer]
PublicKey = ${config.server.publicKey}
${client.preSharedKey ? `PresharedKey = ${client.preSharedKey}\n` : ''
}AllowedIPs = ${WG_ALLOWED_IPS}
PersistentKeepalive = ${WG_PERSISTENT_KEEPALIVE}
Endpoint = ${WG_HOST}:${WG_CONFIG_PORT}`;
  }

  async getClientQRCodeSVG({ clientId }) {
    const config = await this.getClientConfiguration({ clientId });
    return QRCode.toString(config, {
      type: 'svg',
      width: 512,
    });
  }

  async createClient({ name, dataLimit, days }) {
    if (!name) {
      throw new Error('Missing: Name');
    }
    const config = await this.getConfig();
    const privateKey = await Util.exec('wg genkey');
    const publicKey = await Util.exec(`echo ${privateKey} | wg pubkey`, {
      log: 'echo ***hidden*** | wg pubkey',
    });
    const preSharedKey = await Util.exec('wg genpsk');
    // Calculate next IP
    let address;
    for (let i = 2; i < 255; i++) {
      const client = Object.values(config.clients).find((client) => {
        return client.address === WG_DEFAULT_ADDRESS.replace('x', i);
      });
      if (!client) {
        address = WG_DEFAULT_ADDRESS.replace('x', i);
        break;
      }
    }

    if (!address) {
      throw new Error('Maximum number of clients reached.');
    }

    // Create Client
    const id = crypto.randomUUID();
    const client = {
      id,
      name,
      address,
      privateKey,
      publicKey,
      preSharedKey,
      dataLimit: Number(dataLimit),
      days: Number(days),
      remainingDays: Number(days),
      createdAt: new Date(),
      updatedAt: new Date(),
      activatedAt: new Date(),
      enabled: true,
      dataUsage: 0, // مقدار اولیه مصرف داده
    };

    config.clients[id] = client;

    await this.saveConfig();

    return client;
  }

  async deleteClient({ clientId }) {
    const config = await this.getConfig();

    if (config.clients[clientId]) {
      delete config.clients[clientId];
      await this.saveConfig();
    }
  }

  async enableClient({ clientId }) {
    const client = await this.getClient({ clientId });

    client.enabled = true;
    client.updatedAt = new Date();

    await this.saveConfig();
  }

  async disableClient({ clientId }) {
    const client = await this.getClient({ clientId });

    client.enabled = false;
    client.updatedAt = new Date();

    await this.saveConfig();
  }

  async updateClientName({ clientId, name }) {
    const client = await this.getClient({ clientId });
    client.name = name;
    client.updatedAt = new Date();

    await this.saveConfig();
  }

  async updateClientAddress({ clientId, address }) {
    const client = await this.getClient({ clientId });

    if (!Util.isValidIPv4(address)) {
      throw new ServerError(`Invalid Address: ${address}`, 400);
    }

    client.address = address;
    client.updatedAt = new Date();

    await this.saveConfig();
  }

  async __reloadConfig() {
    await this.__buildConfig();
    await this.__syncConfig();
  }

  async restoreConfiguration(config) {
    debug('Starting configuration restore process.');
    const _config = JSON.parse(config);
    await this.__saveConfig(_config);
    await this.__reloadConfig();
    debug('Configuration restore process completed.');
  }

  async backupConfiguration() {
    debug('Starting configuration backup.');
    const config = await this.getConfig();
    const backup = JSON.stringify(config, null, 2);
    debug('Configuration backup completed.');
    return backup;
  }

  // Shutdown wireguard
  async Shutdown() {
    await Util.exec('wg-quick down wg0').catch(() => {});
  }

  async updateClientDataUsage({ clientId, dataUsage }) {
    const client = await this.getClient({ clientId });

    client.dataUsage = dataUsage;
    await this.saveConfig();
  }

  async saveDataUsageUpdates() {
    const clients = await this.getClients();

    for (const client of clients) {
      const getclient = await this.getClient({ clientId: client.id });

      // بررسی اینکه activatedAt وجود دارد
      if (getclient.activatedAt) {
        const now = new Date();
        const activatedAt = new Date(getclient.activatedAt);

        // محاسبه تعداد روزهای سپری‌شده
        const timeDifference = now.getTime() - activatedAt.getTime(); // تفاوت زمانی به میلی‌ثانیه
        const daysPassed = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); // تبدیل به تعداد روز

        // محاسبه تعداد روزهای باقی‌مانده
        const remainingDays = getclient.days - daysPassed;
        getclient.remainingDays = remainingDays > 0 ? remainingDays : 0;
      } else {
        console.log(`Client ${getclient.name} does not have an activatedAt date.`);
      }
    }

    await this.saveConfig(); // تنها یک بار ذخیره‌سازی
    this.dataUsageUpdates = {}; // پاک‌سازی داده‌های مصرف
  }

  startPeriodicUpdates() {
    setInterval(() => {
      this.checkClientsStatus();
      this.saveDataUsageUpdates();
    }, 3600);
  }

  async checkClientsStatus() {
    const clients = await this.getClients();
    for (const client of clients) {
      const getClient = await this.getClient({ clientId: client.id });

      if (client.remainingDays <= 0) {
        console.log(`کاربر ${getClient.name} به دلیل اتمام روزهای مجاز غیرفعال شد.`);
        await this.disableClient({ clientId: getClient.id });
        continue;
      }

      const convertGBtoBytes = (gigabytes) => Number(gigabytes) * 1073741824;
      const dataLimitInBytes = convertGBtoBytes(getClient.dataLimit);

      if (getClient.dataLimit && getClient.dataUsage >= dataLimitInBytes) {
        await this.disableClient({ clientId: getClient.id });
      }
    }
  }

  async getClientStats() {
    const clients = await this.getClients(); // دریافت تمام کاربران

    const activeClients = clients.filter((client) => client.enabled).length; // تعداد کاربران فعال
    const inactiveClients = clients.filter((client) => !client.enabled).length; // تعداد کاربران غیرفعال
    const totalClients = clients.length; // تعداد کل کاربران
    const totalDataUsage = clients.reduce((total, client) => {
      return total + client.dataUsage; // جمع مصرف داده‌ها
    }, 0);

    const usageStats = {
      hourly: totalDataUsage / 3600000, // مصرف داده کل در یک ساعت
      daily: totalDataUsage / 86400000, // مصرف داده کل در یک روز
      weekly: totalDataUsage / 604800000, // مصرف داده کل در یک هفته
      monthly: totalDataUsage / 2592000000, // مصرف داده کل در یک ماه
    };
    // ده کاربر با بیشترین مصرف داده
    const topClients = clients
      .filter((client) => client.enabled) // فقط کاربران فعال
      .sort((a, b) => b.dataUsage - a.dataUsage) // مرتب‌سازی بر اساس مصرف داده
      .slice(0, 10) // انتخاب ده کاربر برتر
      .map((client) => ({
        name: client.name,
        days: client.days,
        remainingDays: client.remainingDays,
        dataUsage: client.dataUsage,
        terrafic: client.dataLimit,
      }));
    const inactiveClientDetails = clients
      .filter((client) => !client.enabled) // فقط کاربران غیرفعال
      .map((client) => ({
        name: client.name,
        dataUsage: client.dataUsage,
        remainingDays: client.remainingDays,
      }));
    return {
      activeClients,
      inactiveClients,
      totalClients,
      topClients,
      usageStats,
      inactiveClientDetails,
    };
  }

  async updateClient({
    clientId,
    clientEditName,
    clientEditDays,
    clientEditDataLimit,
  }) {
    // دریافت کلاینت بر اساس clientId
    const client = await this.getClient({ clientId });

    // به‌روزرسانی مشخصات کلاینت
    client.name = clientEditName;
    client.dataLimit = clientEditDataLimit;
    client.days = clientEditDays;
    client.updatedAt = new Date();

    // ذخیره تغییرات
    await this.saveConfig();

    return client; // بازگرداندن کلاینت برای تایید موفقیت‌آمیز بودن عملیات
  }

};
